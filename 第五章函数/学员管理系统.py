# 递归
# 编程思想：如何利用数学模型，
# 来解决对应的需求问题；
# 然后利用代码实现对应的数据模型（逻辑）
# 算法：使用代码实现对应的数学模型，从而解决对应的业务问题
# 递推算法：递推算法是一种简单的算法，即通过已知条件，
# 利用特定条件得出中间推论，直至得到结果的算法。递推又分为顺推和逆推。
# 顺推：通过最简单的条件，然后逐步推演结果
# 逆推：通过结果找到规律，然后推导已知条件
# 举个栗子：斐波那契数列  =>   1   1   2   3   5   8   13  …
# 找规律：第一个数是1，第二个数1，从第三个数开始：结果等于前两个数的和
# 顺推：想办法把要求的位置之前的所有值都列出来，
# 那么要求的数就可以通过前两个数之和计算出来。

# 程序调用自身的编程技巧称为递归（ recursion）。
# 递归做为一种算法在程序设计语言中广泛应用，
# 它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解，
# 递归策略只需少量的程序就可描述出解题过程所需要的多次重复计算，大大地减少了程序的代码量。
# ① 简化问题：找到最优子问题（不能再小）
# ② 函数自己调用自己
# def  func(参数)
#     …
#     func(参数)
# 斐波那契数列：1 1  2  3  5  8   13  …
# 需求：求指定位置的数据
# 找规律：第一个数是1，第二个数1，从第三个数开始：结果等于前两个数的和
# f(n) = f(n-1) + f(n-2)
# f(n-1) = f(n-2) + f(n-3)
# …
# f(3) = f(2) + f(1)
# f(2) = f(1) = 1
# 递归有两个非常重要的概念：
# ① 递归点：找到解决当前问题的等价函数（先解决规模比当前问题小一些的函数，
# 依次类推，最终实现对问题的解决） => 有递有归
# ② 递归出口：当问题解决的时候，已经到达（必须存在）最优问题，不能再次调用函数了
# 注：如果一个递归函数没有递归出口就变成了死循环
# 递归三要素
# ① 明确你这个函数想要干什么
# ② 寻找递归结束条件
# ③ 找出函数的等价关系式

# 明确你这个函数想要干什么
# 对于递归，很重要的一个事就是，这个函数的功能是什么，
# 他要完成什么样的一件事，而这个，是完全由你自己来定义的。
# 也就是说，我们先不管函数里面的代码什么，而是要先明白，你这个函数是要用来干什么。
# 例如，我定义了一个函数
# // 算 n 的阶乘(假设n不为0)
# def f (n){
# }
# 这个函数的功能是算 n 的阶乘。好了，
# 我们已经定义了一个函数，并且定义了它的功能是什么，接下来我们看第二要素。

# 寻找递归结束条件
# 所谓递归，就是会在函数内部代码中，调用这个函数本身，
# 所以，我们必须要找出递归的结束条件，不然的话，会一直调用自己，
# 进入无底洞。也就是说，我们需要找出当参数为啥时，递归结束，
# 之后直接把结果返回，请注意，这个时候我们必须能根据这个参数的值，
# 能够直接知道函数的结果是什么。
# 例如，上面那个例子，当 n = 1 时，
# 那你应该能够直接知道 f(n) 是啥吧？
# 此时，f(1) = 1。完善我们函数内部的代码，
# 把第二要素加进代码里面，如下：
# // 算 n 的阶乘(假设n不为0)
# def f(n){
#     if(n == 1){
#         return 1;
#     }
# }

# 找出函数的等价关系式
# 第三要素就是，我们要不断缩小参数的范围，
# 缩小之后，我们可以通过一些辅助的变量或者操作，使原函数的结果不变。
# 例如，f(n) 这个范围比较大，我们可以让
# f(n) = n * f(n-1)。这样，范围就由 n 变成了 n-1 了，
# 范围变小了，并且为了原函数f(n) 不变，我们需要让 f(n-1) 乘以 n。
# 说白了，就是要找到原函数的一个等价关系式，
# f(n) 的等价关系式为 n * f(n-1)，即
# f(n) = n * f(n-1)
# 找出了这个等价，继续完善我们的代码，
# 我们把这个等价式写进函数里。如下：

# lambda 表达式
# 如果一个函数有一个返回值，并且只有一句代码，可以使用 lambda简化。
# lambda 参数列表 ： 表达式
# 注意事项
# lambda表达式的参数可有可无，函数的参数在lambda表达式中完全适用。
# lambda表达式能接收任何数量的参数但只能返回一个表达式的值
# # 函数
def fn1():
    return 100
print(fn1)
print(fn1())
print("==========================")
# lambda表达式  fn2和fn1的效果是一样的·
fn2 = lambda: 100
print(fn2)
print(fn2())


def add(a, b):
    return a + b
result = add(1, 2)
print(result)

# 这就是一个函数 后面是返回语句
fn1 = lambda a, b: a + b
print(fn1(1, 2))
