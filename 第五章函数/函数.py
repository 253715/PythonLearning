# 函数的作用
# 输入密码后显示"选择功能"界面
# 查询余额后显示"选择功能"界面
# 取2000钱后显示"选择功能"界面
# 思考一个问题：显示“选择功能”界面需要重复输出给用户，要怎么实现呢？答：使用函数

# 什么是函数
# 函数是一个被命名的、独立的、完成特定功能的代码段，其可能给调用它的程序一个返回值。
# 被命名的：在Python中，大部分函数都是有名函数
# 完成特定功能的代码段：函数的功能要专一，专门为了完成某个功能而定义
# 返回值：当函数执行完毕后，其可能会返回一个值给函数的调用处

# 函数的主要作用：
# ① 模块化编程
# ② 代码重用

# 定义
# def 函数名(参数):
#     函数体
#     ...
#     return 返回值
# 调用
# 函数名(参数)
# ① 不同的需求，参数可有可无。
# ② 在Python中，函数必须先定义后使用。


# 定义函数，添加参数，用于实现向不同的人打不同的招呼
def greet(name):
    print(f'您好，{name}')

# 见到同事老张
greet('老张')
# 见到同事老李
greet('老李')
# 见到同事老王
greet('老王')


def print1():
    print("==============================")
# 返回值
# 案例四：函数的设计原则“高内聚、低耦合”，
# 函数执行完毕后，应该主动把数返回给调用处，
# 而不应该都交由print()等函数直接输出。
print1()
# 定义函数，添加参数，用于实现向不同的人打不同的招呼
def greet(name):
    return '您好，' + name
# 见到同事老张
print(greet('老张'))
# 见到同事老李
print("\033[0;31;40m\t" + greet('老李') + "\033[0m")
# 见到同事老王
print("\033[0;36;40m\t" + greet('老王') + "\033[0m")
print1()
def return_num():
    return 1
    return 2

result = return_num()
print(result)  # 1
# 答：只执行了第一个return，原因是因为return可以退出当前函数
# ，导致return下方的代码不执行。
def return_num():
    return 1, 2
result = return_num()
print(result)  # (1, 2)
# 注意：① `return a, b`写法，返回多个数据的时候，
# 默认是元组类型。
# ② return后面可以连接列表、元组或字典，以返回多个值。

# 函数的说明文档
# 思考：定义一个函数后，程序员如何书写程序能够快速提示这个函数的作用？
# 答：注释
# 思考：如果代码多，我们是不是需要在很多代码中找到这个函数定义的位置才能看到注释？
# 如果想更方便的查看函数的作用怎么办？
# 答：函数的说明文档（函数的说明文档也叫函数的文档说明）。
# 定义说明文档
# def 函数名(参数):
#     """ 说明文档的位置 """
#     代码
#     ......
# 查看说明文档
# help(函数名)
print1()
def sum_num(a, b):
    """ 求和函数 """
    return a + b


help(sum_num)

# 函数的嵌套
# def testB():
#     print('---- testB start----')
#     print('这里是testB函数执行的代码...(省略)...')
#     print('---- testB end----')
#
# def testA():
#     print('---- testA start----')
#     testB()
#     print('---- testA end----')
#
# testA()

# 应用案例
# 打印直线
def print_line():
    print('-' * 20)
print_line()

print1()
# 变量作用阈值
# 变量作用域指的是变量的作用范围（变量在哪里可用，在哪里不可用），
# 主要分为两类：局部变量和全局变量。
# 所谓局部变量是定义在函数体内部的变量，即只在函数体内部生效
def testA():
    a = 100
    print(a)


testA()   # 100
# 变量a是定义在`testA`函数内部的变量，
# 在函数外部访问则立即报错。
# 局部变量的作用：在函数体内部，
# 临时保存数据，即当函数调用完成后，则销毁局部变量。
# print(a)  # 报错：name 'a' is not defined

# 所谓全局变量，指的是在函数体内、外都能生效的变量。
# 思考：如果有一个数据，在函数A和函数B中都要使用，该怎么办？
# 答：将这个数据存储在一个全局变量里面。

# 定义全局变量a
a = 100
def testA():
    print(a)  # 访问全局变量a，并打印变量a存储的数据

def testB():
    print(a)  # 访问全局变量a，并打印变量a存储的数据

testA()  # 100
testB()  # 100

# 3、global关键字  就是在函数体内设置全局变量
# 思考：`testB`函数需求修改变量a的值为200，如何修改程序？
a = 100
def testA():
    print(a)

def testB():
    # global 关键字声明a是全局变量
    global a
    a = 200
    print(a)

testA()  # 100
testB()  # 200
print(f'全局变量a = {a}')  # 全局变量a = 200
print1()
# 4、多函数程序执行流程
# ☆ 共享全局变量一般在实际开发过程中，
# 一个程序往往由多个函数（后面知识中会讲解类）组成，
# 并且多个函数共享某些数据，如下所示：
# 1. 定义全局变量
num = 0
def test1():
    global num
    # 修改全局变量
    num = 100
def test2():
    # 调用test1函数中修改后的全局变量
    print(num)

# 2. 调用test1函数，执行函数内部代码：声明和修改全局变量
test1()
# 3. 调用test2函数，执行函数内部代码：打印
test2()  # 100

# 函数参数
# 1 位置参数：调用函数时根据函数定义的参数位置来传递参数。
def user_info(name, age, gender):
    print(f'您的名字是{name}, 年龄是{age}, 性别是{gender}')
# 注意：递和定义参数的顺序及个数必须一致。
user_info('TOM', 20, '男')
print1()
# 2、关键字参数
# 函数调用，通过“键=值”形式加以指定。
# 可以让函数更加清晰、容易使用，同时也清除了参数的顺序需求。
# 函数调用时，如果有位置参数时，
# 位置参数必须在关键字参数的前面，但关键字参数之间不存在先后顺序。
def user_info(name, age, gender):
    print(f'您的名字是{name}, 年龄是{age}, 性别是{gender}')
# 没有位置上的先后关系 都是通过等
user_info('Rose', age=20, gender='女')
user_info('小明', gender='男', age=16)
print1()
# 3、缺省参数（默认值）
# 缺省参数也叫默认参数，用于定义函数，为参数提供默认值，
# 调用函数时可不传该默认参数的值（注意：
# 所有位置参数必须出现在默认参数前，包括函数定义和调用）。
# 函数调用时，如果为缺省参数传值则修改默认参数值；否则使用这个默认值。
def user_info(name, age, gender='男'):
    print(f'您的名字是{name}, 年龄是{age}, 性别是{gender}')
# 这里参数使用了默认值为男
user_info('TOM', 20)
# 这里没有缺省 所以就没有使用默认值
user_info('Rose', 18, '女')

# 不定长参数
# 不定长参数也叫可变参数。用于不确定调用的时候会传递多少个参数(不传参也可以)的场景。
# 此时，可用包裹(packing)位置参数，或者包裹关键字参数，来进行参数传递，会显得非常方便。
def user_info(*args):
    print(args)
# 注意：传进的所有参数都会被args变量收集，
# 它会根据传进参数的位置合并为一个元组(tuple)，args是元组类型，这就是包裹位置传递
# ('TOM',)
user_info('TOM')
# ('TOM', 18)
user_info('TOM', 18)
print1()
# 包裹关键字传递
# 综上：无论是包裹位置传递还是包裹关键字传递，都是一个组包的过程。
def user_info(**kwargs):
    print(kwargs)

# {'name': 'TOM', 'age': 18, 'id': 110}
user_info(name='TOM', age=18, id=110)